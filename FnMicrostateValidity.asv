function MSResults = FnMicrostateValidity(Preprocessed, Param)
%% -------------------- Microstate Validity Indicator (MVI) --------------------
% Computes global and time-varying MVI for EEG data
% Inputs:
%   Preprocessed: FieldTrip-style EEG data (trial, fsample) OR raw matrix
%   Param (optional): struct with fields
%       .Bands = [4 7; 8 12; 13 30; 31 45];  % freq bands [Hz]
%       .WinMs = 200; .StepMs = 50;         % window size/step (ms)
% Output:
%   MSResults: struct containing global + time-varying MVI metrics

%% --- Default Parameters
if nargin < 2, Param = struct(); end
if ~isfield(Param,'Bands'), Param.Bands = [4 7; 8 12; 13 30; 31 45]; end
if ~isfield(Param,'WinMs'), Param.WinMs = 200; end
if ~isfield(Param,'StepMs'), Param.StepMs = 50; end

%% --- Extract EEG matrix + fs
if isstruct(Preprocessed) && isfield(Preprocessed,'trial')
    EEGDataMat = cell2mat(Preprocessed.trial);   % nCh x nSamp
    fs = Preprocessed.fsample;
else
    EEGDataMat = Preprocessed;                   % assume matrix input
    if ~isfield(Param,'fs')
        error('Provide Param.fs when passing raw matrix.');
    end
    fs = Param.fs;
end

%% --- Global covariance diagnostics
Cx = cov(EEGDataMat');
[FE1, reff] = getFE1reff(Cx);

%% --- Band-specific variance fractions
numBands = size(Param.Bands,1);
phi_b = zeros(1,numBands);
for b = 1:numBands
    band = Param.Bands(b,:);
    data_f = bandpassEEG(EEGDataMat, band, fs);
    Cb = cov(data_f');
    phi_b(b) = trace(Cb)/(trace(Cx)+eps);
end
phi_max = max(phi_b);

%% --- RÃ©nyi Information Dimension proxy (global)
dR = estimateRID(EEGDataMat, fs);

%% --- Global MVI
MVI = (FE1/reff) * (1/(1+(dR-1))) * phi_max;
ValidityDecision = ternary(MVI > 0.5, ...
    'One-hot microstate model valid', ...
    'One-hot model likely invalid; use subspace-aware methods');

%% --- Time-varying diagnostics
winSamps  = round(Param.WinMs*fs/1000);
stepSamps = round(Param.StepMs*fs/1000);
nWins = floor((size(EEGDataMat,2)-winSamps)/stepSamps)+1;

FE1_tv = nan(1,nWins); reff_tv = nan(1,nWins);
dR_tv = nan(1,nWins); MVI_tv = nan(1,nWins);
phi_tv = nan(numBands,nWins);

for w = 1:nWins
    idx = (1:winSamps) + (w-1)*stepSamps;
    Xw = EEGDataMat(:,idx);
    Cxw = cov(Xw');
    [FE1_tv(w), reff_tv(w)] = getFE1reff(Cxw);

    % band fractions in window
    for b = 1:numBands
        Xf = bandpassEEG(Xw, Param.Bands(b,:), fs);
        Cb = cov(Xf');
        phi_tv(b,w) = trace(Cb)/(trace(Cxw)+eps);
    end
    phiMax_w = max(phi_tv(:,w));

    % RID per window
    dR_tv(w) = estimateRID(Xw, fs);

    % MVI per window
    MVI_tv(w) = (FE1_tv(w)/reff_tv(w)) * (1/(1+(dR_tv(w)-1))) * phiMax_w;
end

%% --- Store results
MSResults.Meta.fs = fs;
MSResults.Meta.Bands = Param.Bands;
MSResults.Meta.WinMs = Param.WinMs;
MSResults.Meta.StepMs = Param.StepMs;

MSResults.Validity.Global.FE1       = FE1;
MSResults.Validity.Global.reff      = reff;
MSResults.Validity.Global.RID       = dR;
MSResults.Validity.Global.PhiBands  = phi_b;
MSResults.Validity.Global.PhiMax    = phi_max;
MSResults.Validity.Global.MVI       = MVI;
MSResults.Validity.Global.Decision  = ValidityDecision;

MSResults.Validity.TimeVarying.FE1      = FE1_tv;
MSResults.Validity.TimeVarying.reff     = reff_tv;
MSResults.Validity.TimeVarying.RID      = dR_tv;
MSResults.Validity.TimeVarying.PhiBands = phi_tv;
MSResults.Validity.TimeVarying.MVI      = MVI_tv;
MSResults.Validity.TimeVarying.Tvec     = ((1:nWins)-1)*Param.StepMs/1000;

end

%% -------------------- Helper functions --------------------

function [FE1, reff] = getFE1reff(Cx)
    lam = sort(eig(Cx),'descend');
    if isempty(lam), lam = eps; end
    FE1  = lam(1)/(sum(lam)+eps);
    reff = (sum(lam))^2 /(sum(lam.^2)+eps);
end

function Xf = bandpassEEG(X, band, fs)
    nyq = fs/2; W = band/nyq;
    ord = min(128, floor((size(X,2)-1)/3));
    if ord < 2
        Xf = X;
    else
        b = fir1(ord, W, 'bandpass');
        Xf = filtfilt(b,1,double(X'))';
    end
end

function dR = estimateRID(DataMat, fs)
    winMs = 200; stepMs = 50; nScales = 10;
    winSamps  = round(winMs*fs/1000);
    stepSamps = round(stepMs*fs/1000);
    scales = logspace(-2,0,nScales);

    [~, ns] = size(DataMat);
    X = zscore(DataMat,0,2);
    slopes = [];

    for start = 1:stepSamps:(ns-winSamps+1)
        win = X(:, start:start+winSamps-1);
        Hs = zeros(1,nScales);
        for si = 1:nScales
            eps_val = scales(si)*median(std(win,0,2));
            if eps_val <= 0, continue; end
            q = floor(win/eps_val);
            [~,~,ic] = unique(q','rows');
            p = histcounts(ic,1:(max(ic)+1),'Normalization','probability');
            Hs(si) = -sum(p.*log(p+eps));
        end
        coeffs = polyfit(log(1./scales), Hs, 1);
        slopes(end+1) = coeffs(1);
    end
    if isempty(slopes), dR = 1; else, dR = max(1, median(slopes)); end
end

function out = ternary(cond,a,b)
    if cond, out = a; else, out = b; end
end
